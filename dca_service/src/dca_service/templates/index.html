<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project_name }} - Transaction History</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.css">
    <style>
        body { padding-top: 20px; background-color: #f8f9fa; }
        .container { max-width: 1200px; }
        .status-badge { font-size: 0.9em; }
        /* Ensure tooltips are visible */
        [title] {
            cursor: help;
        }
        #remainingBudget[title] {
            cursor: help !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="d-flex justify-content-between align-items-center mb-3">
            <h1>{{ project_name }}</h1>
            <div>
                <a href="/settings/binance" class="btn btn-outline-secondary me-2">Binance Settings</a>
                <a href="/strategy" class="btn btn-outline-secondary me-2">Strategy Config</a>
                <button id="simulateBtn" class="btn btn-primary">Simulate Transaction</button>
            </div>
        </header>

        <!-- Global Refresh Status Bar -->
        <div class="card shadow-sm mb-4">
            <div class="card-body py-2">
                <div class="d-flex justify-content-between align-items-center">
                    <div class="text-muted small">
                        <strong>Last refresh:</strong> <span id="globalRefreshTime">Loading...</span>
                    </div>
                    <button id="globalRefreshBtn" class="btn btn-sm btn-outline-primary">
                        üîÑ Refresh Dashboard
                    </button>
                </div>
            </div>
        </div>

        <!-- Holdings & Target Section (Phase 7) -->
        <div class="card shadow-sm mb-4">
            <div class="card-header bg-white">
                <h5 class="mb-0">Holdings & Target</h5>
            </div>
            <div class="card-body">
                <div id="holdingsError" class="alert alert-warning d-none">
                    Binance not connected. Please configure your API key below.
                </div>
                <div id="holdingsContent" class="d-none">
                    <div class="row text-center mb-3">
                        <div class="col-md-4">
                            <div class="text-muted small">Total BTC Balance</div>
                            <div class="h4" id="btcBalance">--</div>
                            <div class="small text-muted">
                                <span id="hotBalance" title="Binance (Hot)">Hot: --</span> | 
                                <span id="coldBalance" title="Ledger (Cold)">Cold: --</span>
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-sm btn-outline-info" data-bs-toggle="modal" data-bs-target="#manualEntryModal" title="Manual entry for Ledger/cold wallet BTC. Does not affect Binance balance.">
                                    + Add Cold Wallet BTC
                                </button>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-muted small">Quote Balance (<span id="quoteAsset">USDC</span>)</div>
                            <div class="h4" id="quoteBalance">--</div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-muted small">Target Progress</div>
                            <div class="h4" id="progressPercent">--%</div>
                            <div class="text-muted small" id="targetAmount">Target: -- BTC</div>
                        </div>
                    </div>
                    <div class="progress" style="height: 20px;">
                        <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DCA Control Section -->
        <div class="card shadow-sm mb-4">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">DCA Preview & Control</h5>
                <div>
                    <span id="dataSourceBadge" class="badge bg-secondary me-2">Source: --</span>
                    <span id="scheduleDisplay" class="badge bg-info text-dark">Loading Schedule...</span>
                </div>
            </div>
            <div class="card-body">
                <div id="metricsWarning" class="alert alert-danger d-none">
                    <strong>Warning:</strong> Metrics are stale or unavailable. DCA execution disabled.
                </div>
                <div class="row text-center mb-3">
                    <div class="col-md-2">
                        <div class="text-muted small">AHR999 Index</div>
                        <div class="h4" id="previewAhr">--</div>
                    </div>
                    <div class="col-md-2">
                        <div class="text-muted small">Current Price</div>
                        <div class="h4" id="previewPrice">--</div>
                    </div>
                    <div class="col-md-2">
                        <div class="text-muted small">Strategy Band</div>
                        <div class="h4" id="previewBand">--</div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-muted small">Remaining Budget</div>
                        <div class="h4" id="remainingBudget" style="cursor: help;" data-bs-toggle="tooltip" data-bs-placement="top" title="Loading budget information...">--</div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-muted small">Suggested Action</div>
                        <div class="h4 text-primary" id="previewAction">--</div>
                    </div>
                </div>
                
                <div class="alert alert-light border mb-3" id="previewReasonBox">
                    <div>
                        <strong>Status:</strong> <span id="previewReason">Loading...</span>
                    </div>
                </div>

                <div class="d-flex justify-content-end">
                    <button id="executeSimulatedBtn" class="btn btn-success" disabled>
                        Simulate DCA Now
                    </button>
                </div>
            </div>
        </div>

        <div class="card shadow-sm mb-5">
            <div class="card-header bg-white">
                <h5 class="mb-0">Transaction History</h5>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead class="table-light">
                            <tr>
                                <th>ID</th>
                                <th>Timestamp</th>
                                <th>Status</th>
                                <th>Source</th>
                                <th>Fiat Amount</th>
                                <th>Fee</th>
                                <th>BTC Amount</th>
                                <th>Price</th>
                                <th>AHR999</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody id="transactionsTable">
                            <!-- Data will be loaded here -->
                        </tbody>
                    </table>
                </div>
                <div class="card-footer bg-white">
                    <div class="d-flex justify-content-between align-items-center">
                        <button id="prevPageBtn" class="btn btn-sm btn-outline-secondary" disabled>‚Üê Previous</button>
                        <span id="pageInfo" class="text-muted small">Page 1 of 1</span>
                        <button id="nextPageBtn" class="btn btn-sm btn-outline-secondary" disabled>Next ‚Üí</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Manual Entry Modal (Phase 8) -->
    <div class="modal fade" id="manualEntryModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Update Cold Wallet Balance</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="manualEntryForm">
                        <div class="alert alert-info small">
                            Enter the amount of BTC added to your Ledger (Cold Wallet).
                        </div>
                        <div class="mb-3">
                            <label class="form-label">BTC Amount</label>
                            <input type="number" step="0.00000001" class="form-control" id="manualBtc" required>
                            <div class="form-text">Positive value adds to cold wallet balance.</div>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Fee (BTC) <span class="text-muted small">(Optional)</span></label>
                            <input type="number" step="0.00000001" class="form-control" id="manualFee">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Notes</label>
                            <textarea class="form-control" id="manualNotes" rows="2" placeholder="e.g. Withdrawal from Binance"></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Timestamp</label>
                            <div class="row">
                                <div class="col-md-8">
                                    <input type="datetime-local" class="form-control" id="manualTimestamp" required>
                                </div>
                                <div class="col-md-4">
                                    <select class="form-select" id="manualTimezone">
                                        <option value="Europe/Berlin" selected>Germany</option>
                                        <option value="UTC">UTC</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary w-100">Record Entry</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.js"></script>
    <script>
        window.notyf = new Notyf({
            duration: 3000,
            dismissible: true,
            position: { x: 'right', y: 'top' }
        });
    </script>
    <script>
        // Timezone and formatting utilities
        function convertToUTC(datetimeLocal, timezone) {
            // datetime-local gives us a string like "2025-11-22T15:30"
            // We need to interpret it in the specified timezone and convert to UTC
            if (timezone === 'UTC') {
                // If already UTC, just append Z
                return new Date(datetimeLocal + 'Z').toISOString();
            } else if (timezone === 'Europe/Berlin') {
                // Parse as Germany time, convert to UTC
                const parts = datetimeLocal.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
                if (!parts) return null;
                
                const [, year, month, day, hour, minute] = parts;
                
                // Create date string that can be parsed as Germany time
                const dateStr = `${year}-${month}-${day}T${hour}:${minute}:00`;
                
                // Create temporary date object (this will be in local browser timezone)
                const tempDate = new Date(dateStr);
                
                // Better approach: Use Intl to get the offset
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'Europe/Berlin',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false,
                    timeZoneName: 'longOffset'
                });
                
                // Create a reference date to get the offset
                const refDate = new Date(`${year}-${month}-${day}T12:00:00Z`);
                const formatted = formatter.format(refDate);
                
                // Extract offset from formatted string (e.g., "GMT+01:00" or "GMT+02:00")
                const offsetMatch = formatted.match(/GMT([+-])(\d{2}):(\d{2})/);
                let offsetHours = 1; // Default to CET (UTC+1)
                if (offsetMatch) {
                    const sign = offsetMatch[1] === '+' ? 1 : -1;
                    offsetHours = sign * parseInt(offsetMatch[2]);
                }
                
                // Now convert: Germany time - offset = UTC
                const utcDate = new Date(Date.UTC(year, month - 1, day, hour, minute, 0));
                const correctedUTC = new Date(utcDate.getTime() - offsetHours * 60 * 60 * 1000);
                
                return correctedUTC.toISOString();
            }
            return null;
        }
        
        // Format timestamp for global refresh bar (YYYY-MM-DD HH:MM (Local) ¬∑ HH:MM UTC)
        function formatGlobalRefreshTime(isoString) {
            if (!isoString) return 'Never';
            
            const date = new Date(isoString);
            
            // Local time in 24-hour format
            const localDate = date.toLocaleString('sv-SE', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            }).replace(' ', ' ');
            
            // UTC time in 24-hour format
            const utcHours = String(date.getUTCHours()).padStart(2, '0');
            const utcMinutes = String(date.getUTCMinutes()).padStart(2, '0');
            
            return `${localDate} (Local) ¬∑ ${utcHours}:${utcMinutes} UTC`;
        }
        
        // Format timestamp for transaction table (Local 24-hour, UTC in tooltip)
        function formatTransactionTimestamp(isoString) {
            if (!isoString) return '--';
            
            let dateStr = isoString;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('T')) {
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            } else if (!dateStr.endsWith('Z') && dateStr.includes('T') && !dateStr.includes('+')) {
                dateStr = dateStr + 'Z';
            }
            
            const date = new Date(dateStr);
            
            // Local time in 24-hour format
            const localTime = date.toLocaleString('sv-SE', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            
            // UTC time for tooltip
            const utcTime = date.toISOString().replace('T', ' ').substring(0, 16);
            
            return { display: localTime, utcTooltip: `UTC: ${utcTime}` };
        }
        
        function formatTimestampInTimezone(isoString, timezone) {
            // Legacy function for manual entry modal
            let dateStr = isoString;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('T')) {
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            } else if (!dateStr.endsWith('Z') && dateStr.includes('T') && !dateStr.includes('+')) {
                dateStr = dateStr + 'Z';
            }
            
            const date = new Date(dateStr);
            
            if (timezone === 'UTC') {
                return date.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
            } else if (timezone === 'Europe/Berlin') {
                return date.toLocaleString('de-DE', {
                    timeZone: 'Europe/Berlin',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                }) + ' CET/CEST';
            }
            return isoString;
        }
        
        // Pagination state
        let allTransactions = [];
        let currentPage = 1;
        const rowsPerPage = 20;
        
        async function loadTransactions() {
            try {
                const response = await fetch('/api/transactions?limit=100');
                allTransactions = await response.json();
                
                // Reset to page 1
                currentPage = 1;
                renderTransactionPage();
            } catch (error) {
                console.error('Error loading transactions:', error);
            }
        }
        
        function renderTransactionPage() {
            const tbody = document.getElementById('transactionsTable');
            tbody.innerHTML = '';
            
            const totalPages = Math.ceil(allTransactions.length / rowsPerPage);
            const startIdx = (currentPage - 1) * rowsPerPage;
            const endIdx = startIdx + rowsPerPage;
            const pageTransactions = allTransactions.slice(startIdx, endIdx);
            
            pageTransactions.forEach(tx => {
                const row = document.createElement('tr');
                
                // Format timestamp with tooltip
                const timestampData = formatTransactionTimestamp(tx.timestamp);
                
                const statusClass = tx.status === 'SUCCESS' ? 'bg-success' : 
                                  tx.status === 'FAILED' ? 'bg-danger' : 'bg-secondary';
                
                // Source badge
                const source = tx.source || 'SIMULATED';
                let sourceBadge = '';
                if (source === 'SIMULATED') {
                    sourceBadge = '<span class="badge bg-secondary status-badge">SIM</span>';
                } else if (source === 'BINANCE') {
                    sourceBadge = '<span class="badge bg-primary status-badge">BIN</span>';
                } else if (source === 'LEDGER') {
                    sourceBadge = '<span class="badge bg-info text-dark status-badge">LEDGER</span>';
                } else if (source === 'MANUAL') {
                    sourceBadge = '<span class="badge bg-secondary status-badge">MANUAL</span>';
                } else {
                    sourceBadge = `<span class="badge bg-secondary status-badge">${source}</span>`;
                }
                
                // Fee display
                let feeDisplay = '‚Äî';
                if (tx.fee_amount !== null && tx.fee_amount !== undefined && tx.fee_amount > 0) {
                    const feeAsset = tx.fee_asset || 'USDC';
                    feeDisplay = `${tx.fee_amount.toFixed(2)} ${feeAsset}`;
                }
                
                row.innerHTML = `
                    <td>${tx.id}</td>
                    <td title="${timestampData.utcTooltip}">${timestampData.display}</td>
                    <td><span class="badge ${statusClass} status-badge">${tx.status}</span></td>
                    <td>${sourceBadge}</td>
                    <td>${tx.fiat_amount ? '$' + tx.fiat_amount.toFixed(2) : '-'}</td>
                    <td>${feeDisplay}</td>
                    <td>${tx.btc_amount ? tx.btc_amount.toFixed(8) : '-'}</td>
                    <td>${tx.price ? '$' + tx.price.toFixed(2) : '-'}</td>
                    <td>${tx.ahr999 ? tx.ahr999.toFixed(2) : '-'}</td>
                    <td>${tx.notes || '‚Äî'}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Update pagination controls
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage} of ${Math.max(1, totalPages)}`;
            
            document.getElementById('prevPageBtn').disabled = currentPage <= 1;
            document.getElementById('nextPageBtn').disabled = currentPage >= totalPages || totalPages === 0;
        }
        
        // Pagination button handlers
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('prevPageBtn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderTransactionPage();
                }
            });
            
            document.getElementById('nextPageBtn').addEventListener('click', () => {
                const totalPages = Math.ceil(allTransactions.length / rowsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderTransactionPage();
                }
            });
        });

        document.getElementById('simulateBtn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/transactions/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fiat_amount: 100.0,
                        ahr999: 0.45,
                        price: 50000.0,
                        notes: 'Manual simulation'
                    })
                });
                
                if (response.ok) {
                    notyf.success('Simulated transaction created');
                    loadTransactions();
                } else {
                    notyf.error('Simulation failed');
                }
            } catch (error) {
                console.error('Error simulating:', error);
                notyf.error('Network error or backend unreachable');
            }
        });

        async function loadPreview() {
            try {
                // Load Strategy for Schedule
                const stratResponse = await fetch('/api/strategy');
                const strategy = await stratResponse.json();
                if (strategy) {
                    const freq = strategy.execution_frequency.charAt(0).toUpperCase() + strategy.execution_frequency.slice(1);
                    document.getElementById('scheduleDisplay').textContent = `Schedule: ${freq} at ${strategy.execution_time_utc} UTC`;
                }

                // Load Preview
                const response = await fetch('/api/dca/preview');
                const decision = await response.json();
                
                // Update metrics display
                document.getElementById('previewAhr').textContent = decision.ahr999_value.toFixed(2);
                document.getElementById('previewPrice').textContent = '$' + decision.price_usd.toLocaleString();
                document.getElementById('previewBand').textContent = decision.ahr_band.toUpperCase();
                document.getElementById('previewAction').textContent = decision.can_execute 
                    ? `BUY $${decision.suggested_amount_usd.toFixed(2)}` 
                    : 'WAIT';
                
                // Update data source (Phase 6)
                const metricsSource = decision.metrics_source || {backend: 'unknown', label: 'Unknown'};
                const sourceBadge = document.getElementById('dataSourceBadge');
                if (sourceBadge) {
                    sourceBadge.textContent = `Source: ${metricsSource.label}`;
                    sourceBadge.title = metricsSource.label; // Tooltip for full label
                }
                
                // Update status
                document.getElementById('previewReason').textContent = decision.reason;
                
                // Update global refresh timestamp
                updateGlobalRefreshTime(decision.timestamp);
                
                // Update remaining budget
                const remainingBudgetElem = document.getElementById('remainingBudget');
                if (!remainingBudgetElem) {
                    console.error('remainingBudget element not found');
                    return;
                }
                
                if (decision.remaining_budget !== null && decision.remaining_budget !== undefined) {
                    remainingBudgetElem.textContent = '$' + decision.remaining_budget.toFixed(2);
                    
                    // Set tooltip based on reset behavior
                    // Handle both boolean true and string "true" from JSON
                    const budgetResets = decision.budget_resets === true || decision.budget_resets === 'true';
                    let tooltipText = '';
                    
                    if (budgetResets) {
                        // When budget resets monthly (allow_over_budget=False), show time until reset
                        const timeUntilReset = decision.time_until_reset;
                        if (timeUntilReset && String(timeUntilReset).trim() !== '' && timeUntilReset !== 'null' && timeUntilReset !== null) {
                            tooltipText = `Budget resets in ${timeUntilReset}`;
                        } else {
                            tooltipText = 'Budget resets monthly';
                        }
                    } else {
                        // When allow_over_budget=True, budget does not reset
                        tooltipText = 'Budget does not reset in this mode';
                    }
                    
                    // Set tooltip using Bootstrap tooltip API
                    // Destroy existing tooltip instance if any
                    const existingTooltip = bootstrap.Tooltip.getInstance(remainingBudgetElem);
                    if (existingTooltip) {
                        existingTooltip.dispose();
                    }
                    
                    // Update title attribute
                    remainingBudgetElem.setAttribute('data-bs-original-title', tooltipText);
                    remainingBudgetElem.setAttribute('title', tooltipText);
                    
                    // Initialize new Bootstrap tooltip
                    new bootstrap.Tooltip(remainingBudgetElem, {
                        placement: 'top',
                        trigger: 'hover'
                    });
                    
                    // Debug: log tooltip setting
                    console.log('Budget tooltip set:', {
                        budget_resets: decision.budget_resets,
                        time_until_reset: decision.time_until_reset,
                        tooltip: tooltipText,
                        element_title: remainingBudgetElem.getAttribute('title')
                    });
                } else {
                    remainingBudgetElem.textContent = '--';
                    const tooltipText = 'Budget information unavailable';
                    
                    // Update Bootstrap tooltip
                    const existingTooltip = bootstrap.Tooltip.getInstance(remainingBudgetElem);
                    if (existingTooltip) {
                        existingTooltip.dispose();
                    }
                    remainingBudgetElem.setAttribute('data-bs-original-title', tooltipText);
                    remainingBudgetElem.setAttribute('title', tooltipText);
                    new bootstrap.Tooltip(remainingBudgetElem, {
                        placement: 'top',
                        trigger: 'hover'
                    });
                }

                const btn = document.getElementById('executeSimulatedBtn');
                const warningBox = document.getElementById('metricsWarning');

                if (decision.reason.includes("Metrics unavailable") || decision.reason.includes("stale")) {
                    warningBox.classList.remove('d-none');
                    btn.disabled = true;
                    btn.textContent = 'Metrics Error';
                } else {
                    warningBox.classList.add('d-none');
                    if (decision.can_execute) {
                        btn.disabled = false;
                        btn.textContent = `Simulate BUY ($${decision.suggested_amount_usd.toFixed(2)})`;
                    } else {
                        btn.disabled = true;
                        btn.textContent = 'Conditions Not Met';
                    }
                }

            } catch (error) {
                console.error('Error loading preview:', error);
                const reasonElem = document.getElementById('previewReason');
                if (reasonElem) reasonElem.textContent = 'Error loading data';
                notyf.error('Failed to load metrics');
            }
        }
        
        // Helper to update global refresh timestamp
        function updateGlobalRefreshTime(timestamp) {
            const elem = document.getElementById('globalRefreshTime');
            if (elem && timestamp) {
                elem.textContent = formatGlobalRefreshTime(timestamp);
            }
        }

        // Global refresh button handler
        document.addEventListener('DOMContentLoaded', function() {
            const globalBtn = document.getElementById('globalRefreshBtn');
            if (globalBtn) {
                globalBtn.addEventListener('click', async () => {
                    globalBtn.disabled = true;
                    globalBtn.textContent = 'üîÑ Refreshing...';
                    
                    try {
                        await Promise.all([
                            loadPreview(),
                            loadHoldings()
                        ]);
                        notyf.success('Dashboard refreshed');
                    } catch (error) {
                        notyf.error('Failed to refresh dashboard');
                    } finally {
                        globalBtn.disabled = false;
                        globalBtn.textContent = 'üîÑ Refresh Dashboard';
                    }
                });
            }
        });

        document.getElementById('executeSimulatedBtn').addEventListener('click', async () => {
            const btn = document.getElementById('executeSimulatedBtn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Executing...';

            try {
                const response = await fetch('/api/dca/execute-simulated', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.transaction) {
                    notyf.success(`Simulated buy executed: ${result.message}`);
                    // Auto-refresh after successful execution (Phase 6)
                    loadTransactions(); // Refresh history
                    loadPreview();      // Refresh preview (budget might have changed)
                } else {
                    notyf.open({ type: 'warning', message: `Skipped: ${result.message}` });
                    // Don't refresh transactions if skipped, but refresh preview to show updated status
                    loadPreview();
                }
            } catch (error) {
                console.error('Error executing simulated DCA:', error);
                notyf.error('Execution failed');
                btn.disabled = false;
                btn.textContent = originalText;
            }
        });

        // Holdings function still needed by dashboard
        async function loadHoldings() {
            try {
                const response = await fetch('/api/binance/holdings');
                const data = await response.json();
                
                const errorBox = document.getElementById('holdingsError');
                const contentBox = document.getElementById('holdingsContent');
                
                if (data.connected) {
                    errorBox.classList.add('d-none');
                    contentBox.classList.remove('d-none');
                    
                    document.getElementById('btcBalance').textContent = data.btc_balance.toFixed(8) + ' BTC';
                    
                    // Breakdown
                    const hot = data.binance_btc_balance !== null ? data.binance_btc_balance.toFixed(8) : '0.00000000';
                    const cold = data.cold_wallet_btc_balance !== null ? data.cold_wallet_btc_balance.toFixed(8) : '0.00000000';
                    document.getElementById('hotBalance').textContent = `Hot: ${hot}`;
                    document.getElementById('coldBalance').textContent = `Cold: ${cold}`;
                    
                    document.getElementById('quoteBalance').textContent = data.quote_balance.toFixed(2);
                    document.getElementById('quoteAsset').textContent = data.quote_asset;
                    
                    const progress = (data.progress_ratio * 100).toFixed(5);
                    document.getElementById('progressPercent').textContent = progress + '%';
                    document.getElementById('targetAmount').textContent = `Target: ${data.target_btc_amount} BTC`;
                    document.getElementById('progressBar').style.width = progress + '%';
                    
                    // Update global refresh timestamp
                    if (data.holdings_last_updated) {
                        updateGlobalRefreshTime(data.holdings_last_updated);
                    }
                } else {
                    contentBox.classList.add('d-none');
                    errorBox.classList.remove('d-none');
                    if (data.reason === 'no_credentials') {
                        errorBox.textContent = "Binance not connected. Configure your API keys in Binance Settings.";
                    } else {
                        errorBox.textContent = `Connection Error: ${data.reason}`;
                    }
                }
            } catch (error) {
                console.error('Error loading holdings:', error);
            }
        }

        // Manual Entry Form Submission (Phase 8)
        document.getElementById('manualEntryForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Convert timestamp to UTC based on selected timezone
            const timezone = document.getElementById('manualTimezone').value;
            const datetimeLocal = document.getElementById('manualTimestamp').value;
            const timestampUTC = convertToUTC(datetimeLocal, timezone);
            
            if (!timestampUTC) {
                notyf.error('Invalid timestamp');
                return;
            }
            
            const data = {
                btc_amount: parseFloat(document.getElementById('manualBtc').value),
                fee_btc: document.getElementById('manualFee').value ? parseFloat(document.getElementById('manualFee').value) : null,
                notes: document.getElementById('manualNotes').value,
                timestamp: timestampUTC
            };
            
            try {
                const response = await fetch('/api/cold_wallet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    notyf.success('Transaction recorded successfully!');
                    document.getElementById('manualEntryForm').reset();
                    const modal = bootstrap.Modal.getInstance(document.getElementById('manualEntryModal'));
                    modal.hide();
                    loadTransactions();
                    loadHoldings();
                } else {
                    const err = await response.json();
                    notyf.error('Error: ' + err.detail);
                }
            } catch (error) {
                notyf.error('Error submitting transaction');
                console.error(error);
            }
        });

        
        // Load on start (Phase 6: auto-refresh on page load)
        loadTransactions();
        loadPreview();
        loadHoldings();
    </script>
</body>
</html>
