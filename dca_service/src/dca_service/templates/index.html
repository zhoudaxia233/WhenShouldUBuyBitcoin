<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project_name }} - Transaction History</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.css">
    <style>
        body { padding-top: 20px; background-color: #f8f9fa; }
        .container { max-width: 1200px; }
        .status-badge { font-size: 0.9em; }
        /* Ensure tooltips are visible */
        [title] {
            cursor: help;
        }
        #remainingBudget[title] {
            cursor: help !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="mb-3">
            <div class="d-flex flex-column flex-md-row justify-content-between align-items-center gap-3">
                <h1 class="mb-0">{{ project_name }}</h1>
                <div class="d-flex flex-column flex-md-row align-items-center gap-3">
                    <!-- Navigation buttons -->
                    <div class="d-flex flex-wrap justify-content-center gap-2">
                        <a href="/settings/binance" class="btn btn-outline-secondary">Binance Settings</a>
                        <a href="/strategy" class="btn btn-outline-secondary">Strategy Config</a>
                        <a href="/stats" class="btn btn-outline-secondary">Stats & Analytics</a>
                    </div>
                    <!-- User section -->
                    {% if user %}
                    <div class="d-flex align-items-center gap-2 border-start-md ps-md-3 mt-2 mt-md-0 pt-2 pt-md-0 border-top border-top-md-0">
                        <span class="text-muted small">{{ user.email }}</span>
                        <form method="POST" action="/api/auth/logout" class="d-inline">
                            <button type="submit" class="btn btn-sm btn-outline-danger">Logout</button>
                        </form>
                    </div>
                    {% endif %}
                </div>
            </div>
        </header>

        <!-- Global Refresh Status Bar -->
        <div class="card shadow-sm mb-4">
            <div class="card-body py-2">
                <div class="d-flex justify-content-between align-items-center">
                    <div class="text-muted small">
                        <strong>Last refresh:</strong> <span id="globalRefreshTime">Loading...</span>
                    </div>
                    <button id="globalRefreshBtn" class="btn btn-sm btn-outline-primary">
                        üîÑ Refresh Dashboard
                    </button>
                </div>
            </div>
        </div>

        <!-- Wallet Overview Section -->
        <div class="card shadow-sm mb-4">
            <div class="card-header bg-white">
                <h5 class="mb-0">Wallet Overview</h5>
            </div>
            <div class="card-body">
                <div id="walletError" class="alert alert-warning d-none">
                    Configure Binance API credentials to view hot wallet data.
                </div>
                <div id="walletContent">
                    <div class="row text-center mb-3">
                        <!-- Total BTC - Main Display -->
                        <div class="col-md-4">
                            <div class="text-muted small">Total BTC Balance</div>
                            <div class="h3" id="totalBtc">--</div>
                            <div class="small text-muted">
                                <span id="hotBalance" title="Binance (Hot)">Hot: --</span> | 
                                <span id="coldBalance" title="Cold Storage">Cold: --</span>
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-sm btn-outline-info" data-bs-toggle="modal" data-bs-target="#setColdWalletModal" title="Set your total cold wallet BTC balance">
                                    ‚úèÔ∏è Set Cold Wallet
                                </button>
                            </div>
                        </div>
                        
                        <!-- Available USDC (Binance) -->
                        <div class="col-md-3">
                            <div class="text-muted small">Available USDC</div>
                            <div class="h3" id="quoteBalance">--</div>
                            <div class="small text-muted">Binance Balance</div>
                        </div>
                        
                        <!-- Target Progress -->
                        <div class="col-md-4">
                            <div class="text-muted small">Target Progress</div>
                            <div class="h3" id="progressPercent">--%</div>
                            <div class="text-muted small" id="targetAmount">Target: -- BTC</div>
                        </div>
                    </div>
                    
                    <div class="progress" style="height: 20px;">
                        <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DCA Control Section -->
        <div class="card shadow-sm mb-4">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">DCA Preview & Control</h5>
                <div>
                    <span id="execModeBadge" class="badge bg-secondary me-2">Mode: Loading...</span>
                    <span id="dataSourceBadge" class="badge bg-secondary me-2">Source: --</span>
                    <span id="scheduleDisplay" class="badge bg-info text-dark">Loading Schedule...</span>
                </div>
            </div>
            <div class="card-body">
                <div id="metricsWarning" class="alert alert-danger d-none">
                    <strong>Warning:</strong> Metrics are stale or unavailable. DCA execution disabled.
                </div>
                <div class="row text-center mb-3">
                    <div class="col-md-2">
                        <div class="text-muted small">AHR999 Index</div>
                        <div class="h4" id="previewAhr">--</div>
                    </div>
                    <div class="col-md-2">
                        <div class="text-muted small">Current Price</div>
                        <div class="h4" id="previewPrice">--</div>
                    </div>
                    <div class="col-md-2">
                        <div class="text-muted small">Strategy Band</div>
                        <div class="h4" id="previewBand">--</div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-muted small">Remaining Budget</div>
                        <div class="h4" id="remainingBudget" style="cursor: help;" data-bs-toggle="tooltip" data-bs-placement="top" title="Loading budget information...">--</div>
                    </div>
                    <div class="col-md-3">
                        <div class="text-muted small">Suggested Action</div>
                        <div class="h4 text-primary" id="previewAction">--</div>
                    </div>
                </div>
                
                <div class="alert alert-light border mb-3" id="previewReasonBox">
                    <div>
                        <strong>Status:</strong> <span id="previewReason" style="white-space: pre-line; font-family: monospace; font-size: 0.9em;">Loading...</span>
                    </div>
                </div>

                <div class="d-flex justify-content-end">
                    <button id="executeSimulatedBtn" class="btn btn-success" disabled>
                        Test Strategy
                    </button>
                </div>
            </div>
        </div>

        <div class="card shadow-sm mb-5">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Transaction History</h5>
                <button id="clearSimulatedBtn" class="btn btn-sm btn-outline-danger">
                    Reset & Sync History
                </button>
            </div>
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-hover mb-0">
                        <thead class="table-light">
                            <tr>
                                <th>ID</th>
                                <th>Timestamp</th>
                                <th>Status</th>
                                <th>Source</th>
                                <th>Fiat Amount</th>
                                <th>Fee</th>
                                <th>BTC Amount</th>
                                <th>Price</th>
                                <th>AHR999</th>
                            </tr>
                        </thead>
                        <tbody id="transactionsTable">
                            <!-- Data will be loaded here -->
                        </tbody>
                    </table>
                </div>
                <div class="card-footer bg-white">
                    <div class="d-flex justify-content-between align-items-center">
                        <button id="prevPageBtn" class="btn btn-sm btn-outline-secondary" disabled>‚Üê Previous</button>
                        <span id="pageInfo" class="text-muted small">Page 1 of 1</span>
                        <button id="nextPageBtn" class="btn btn-sm btn-outline-secondary" disabled>Next ‚Üí</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Set Cold Wallet Balance Modal -->
    <div class="modal fade" id="setColdWalletModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Set Cold Wallet Balance</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="setColdWalletForm">
                        <div class="alert alert-info small">
                            Set the total amount of BTC currently in your cold storage (Ledger, Trezor, etc.).
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Total BTC Balance</label>
                            <input type="number" step="0.00000001" min="0" class="form-control" id="coldWalletInput" required>
                            <div class="form-text">This replaces the previous value.</div>
                        </div>
                        <button type="submit" class="btn btn-primary w-100">Update Balance</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3.10.0/notyf.min.js"></script>
    <script>
        window.notyf = new Notyf({
            duration: 3000,
            dismissible: true,
            position: { x: 'right', y: 'top' }
        });
    </script>
    <script>
        // Timezone and formatting utilities
        function convertToUTC(datetimeLocal, timezone) {
            // datetime-local gives us a string like "2025-11-22T15:30"
            // We need to interpret it in the specified timezone and convert to UTC
            if (timezone === 'UTC') {
                // If already UTC, just append Z
                return new Date(datetimeLocal + 'Z').toISOString();
            } else if (timezone === 'Europe/Berlin') {
                // Parse as Germany time, convert to UTC
                const parts = datetimeLocal.match(/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})/);
                if (!parts) return null;
                
                const [, year, month, day, hour, minute] = parts;
                
                // Create date string that can be parsed as Germany time
                const dateStr = `${year}-${month}-${day}T${hour}:${minute}:00`;
                
                // Create temporary date object (this will be in local browser timezone)
                const tempDate = new Date(dateStr);
                
                // Better approach: Use Intl to get the offset
                const formatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'Europe/Berlin',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false,
                    timeZoneName: 'longOffset'
                });
                
                // Create a reference date to get the offset
                const refDate = new Date(`${year}-${month}-${day}T12:00:00Z`);
                const formatted = formatter.format(refDate);
                
                // Extract offset from formatted string (e.g., "GMT+01:00" or "GMT+02:00")
                const offsetMatch = formatted.match(/GMT([+-])(\d{2}):(\d{2})/);
                let offsetHours = 1; // Default to CET (UTC+1)
                if (offsetMatch) {
                    const sign = offsetMatch[1] === '+' ? 1 : -1;
                    offsetHours = sign * parseInt(offsetMatch[2]);
                }
                
                // Now convert: Germany time - offset = UTC
                const utcDate = new Date(Date.UTC(year, month - 1, day, hour, minute, 0));
                const correctedUTC = new Date(utcDate.getTime() - offsetHours * 60 * 60 * 1000);
                
                return correctedUTC.toISOString();
            }
            return null;
        }
        
        // Format timestamp for global refresh bar (YYYY-MM-DD HH:MM (Local) ¬∑ HH:MM UTC)
        function formatGlobalRefreshTime(isoString) {
            if (!isoString) return 'Never';
            
            const date = new Date(isoString);
            
            // Local time in 24-hour format
            const localDate = date.toLocaleString('sv-SE', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            }).replace(' ', ' ');
            
            // UTC time in 24-hour format
            const utcHours = String(date.getUTCHours()).padStart(2, '0');
            const utcMinutes = String(date.getUTCMinutes()).padStart(2, '0');
            
            return `${localDate} (Local) ¬∑ ${utcHours}:${utcMinutes} UTC`;
        }
        
        // Format timestamp for transaction table (Local 24-hour, UTC in tooltip)
        function formatTransactionTimestamp(isoString) {
            if (!isoString) return '--';
            
            let dateStr = isoString;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('T')) {
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            } else if (!dateStr.endsWith('Z') && dateStr.includes('T') && !dateStr.includes('+')) {
                dateStr = dateStr + 'Z';
            }
            
            const date = new Date(dateStr);
            
            // Local time in 24-hour format
            const localTime = date.toLocaleString('sv-SE', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });
            
            // UTC time for tooltip
            const utcTime = date.toISOString().replace('T', ' ').substring(0, 16);
            
            return { display: localTime, utcTooltip: `UTC: ${utcTime}` };
        }
        
        function formatTimestampInTimezone(isoString, timezone) {
            // Legacy function for manual entry modal
            let dateStr = isoString;
            if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('T')) {
                dateStr = dateStr.replace(' ', 'T') + 'Z';
            } else if (!dateStr.endsWith('Z') && dateStr.includes('T') && !dateStr.includes('+')) {
                dateStr = dateStr + 'Z';
            }
            
            const date = new Date(dateStr);
            
            if (timezone === 'UTC') {
                return date.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
            } else if (timezone === 'Europe/Berlin') {
                return date.toLocaleString('de-DE', {
                    timeZone: 'Europe/Berlin',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                }) + ' CET/CEST';
            }
            return isoString;
        }
        
        // Pagination state
        let allTransactions = [];
        let currentPage = 1;
        const rowsPerPage = 20;
        
        // Cache Helpers
        function saveToCache(key, data) {
            try {
                const cacheItem = {
                    timestamp: Date.now(),
                    data: data
                };
                localStorage.setItem(key, JSON.stringify(cacheItem));
            } catch (e) {
                console.error('Error saving to cache', e);
            }
        }

        function loadFromCache(key) {
            try {
                const item = localStorage.getItem(key);
                if (!item) return null;
                
                const cacheItem = JSON.parse(item);
                // Optional: Expiry check (e.g. 24 hours), but for dashboard we want instant load
                // even if old, then replace with fresh.
                return cacheItem.data;
            } catch (e) {
                console.error('Error loading from cache', e);
                return null;
            }
        }

        async function loadTransactions() {
            try {
                // Load from cache first
                const cached = loadFromCache('transactions_list');
                if (cached) {
                    allTransactions = cached;
                    renderTransactionPage();
                }

                const response = await fetch('/api/transactions');
                allTransactions = await response.json();
                saveToCache('transactions_list', allTransactions);
                
                // Reset to page 1
                currentPage = 1;
                renderTransactionPage();
            } catch (error) {
                console.error('Error loading transactions:', error);
            }
        }
        
        function renderTransactionPage() {
            const tbody = document.getElementById('transactionsTable');
            tbody.innerHTML = '';
            
            const totalPages = Math.ceil(allTransactions.length / rowsPerPage);
            const startIdx = (currentPage - 1) * rowsPerPage;
            const endIdx = startIdx + rowsPerPage;
            const pageTransactions = allTransactions.slice(startIdx, endIdx);
            
            pageTransactions.forEach(tx => {
                const row = document.createElement('tr');
                
                // Format timestamp with tooltip
                const timestampData = formatTransactionTimestamp(tx.timestamp);
                
                const statusClass = tx.status === 'SUCCESS' ? 'bg-success' : 
                                  tx.status === 'FAILED' ? 'bg-danger' : 'bg-secondary';
                
                // Source badge - SIMULATED (gray), DCA (green), MANUAL (blue)
                const source = tx.source || 'SIMULATED';
                let sourceBadge = '';
                if (source === 'SIMULATED') {
                    sourceBadge = '<span class="badge bg-secondary status-badge">SIMULATED</span>';
                } else if (source === 'DCA') {
                    sourceBadge = '<span class="badge bg-success status-badge">DCA</span>';
                } else if (source === 'MANUAL') {
                    sourceBadge = '<span class="badge bg-info status-badge">MANUAL</span>';
                } else {
                    // Fallback for any other sources
                    sourceBadge = `<span class="badge bg-secondary status-badge">${source}</span>`;
                }

                
                // Fee display
                let feeDisplay = '‚Äî';
                if (tx.fee_amount !== null && tx.fee_amount !== undefined && tx.fee_amount > 0) {
                    const feeAsset = tx.fee_asset || 'USDC';
                    
                    if (feeAsset === 'BTC') {
                        // Convert BTC fee to USD using the transaction price
                        // Use avg_execution_price_usd if available, otherwise fallback to price
                        const price = tx.avg_execution_price_usd || tx.price || 0;
                        if (price > 0) {
                            const feeUSD = tx.fee_amount * price;
                            feeDisplay = `$${feeUSD.toFixed(2)}`;
                        } else {
                            feeDisplay = `${tx.fee_amount.toFixed(8)} BTC`;
                        }
                    } else if (['USDC', 'USDT', 'USD', 'BUSD', 'FDUSD'].includes(feeAsset)) {
                        feeDisplay = `$${tx.fee_amount.toFixed(2)}`;
                    } else {
                        // Other assets (e.g. BNB), display as is
                        feeDisplay = `${tx.fee_amount.toFixed(4)} ${feeAsset}`;
                    }
                }
                
                row.innerHTML = `
                    <td>${tx.id}</td>
                    <td title="${timestampData.utcTooltip}">${timestampData.display}</td>
                    <td><span class="badge ${statusClass} status-badge">${tx.status}</span></td>
                    <td>${sourceBadge}</td>
                    <td>${tx.fiat_amount ? '$' + tx.fiat_amount.toFixed(2) : '-'}</td>
                    <td>${feeDisplay}</td>
                    <td>${tx.btc_amount ? tx.btc_amount.toFixed(8) : '-'}</td>
                    <td>${tx.price ? '$' + tx.price.toFixed(2) : '-'}</td>
                    <td>${tx.ahr999 ? tx.ahr999.toFixed(2) : '-'}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Update pagination controls
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage} of ${Math.max(1, totalPages)}`;
            
            document.getElementById('prevPageBtn').disabled = currentPage <= 1;
            document.getElementById('nextPageBtn').disabled = currentPage >= totalPages || totalPages === 0;
        }
        
        // Pagination button handlers
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('prevPageBtn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderTransactionPage();
                }
            });
            
            document.getElementById('nextPageBtn').addEventListener('click', () => {
                const totalPages = Math.ceil(allTransactions.length / rowsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    renderTransactionPage();
                }
            });
        });



        function updateStrategyUI(strategy) {
            if (strategy) {
                const freq = strategy.execution_frequency.charAt(0).toUpperCase() + strategy.execution_frequency.slice(1);
                document.getElementById('scheduleDisplay').textContent = `Schedule: ${freq} at ${strategy.execution_time_utc} UTC`;
            }
        }

        function updatePreviewUI(decision) {
            // Update metrics display
            document.getElementById('previewAhr').textContent = decision.ahr999_value.toFixed(2);
            document.getElementById('previewPrice').textContent = '$' + decision.price_usd.toLocaleString();
            document.getElementById('previewBand').textContent = decision.ahr_band.toUpperCase();
            document.getElementById('previewAction').textContent = decision.can_execute 
                ? `BUY $${decision.suggested_amount_usd.toFixed(2)}` 
                : 'WAIT';
            
            // Update data source (Phase 6)
            const metricsSource = decision.metrics_source || {backend: 'unknown', label: 'Unknown'};
            const sourceBadge = document.getElementById('dataSourceBadge');
            if (sourceBadge) {
                sourceBadge.textContent = `Source: ${metricsSource.label}`;
                sourceBadge.title = metricsSource.label; // Tooltip for full label
            }
            
            // Update status (support line breaks)
            const reasonElem = document.getElementById('previewReason');
            if (reasonElem) {
                // Replace " | " with newlines for better readability
                reasonElem.textContent = decision.reason.replace(/\s*\|\s*/g, '\n');
            }
            
            // Update global refresh timestamp
            updateGlobalRefreshTime(decision.timestamp);
            
            // Update remaining budget
            const remainingBudgetElem = document.getElementById('remainingBudget');
            if (!remainingBudgetElem) {
                console.error('remainingBudget element not found');
                return;
            }
            
            if (decision.remaining_budget !== null && decision.remaining_budget !== undefined) {
                remainingBudgetElem.textContent = '$' + decision.remaining_budget.toFixed(2);
                
                // Set tooltip based on reset behavior
                // Handle both boolean true and string "true" from JSON
                const budgetResets = decision.budget_resets === true || decision.budget_resets === 'true';
                let tooltipText = '';
                
                if (budgetResets) {
                    // When budget resets monthly (allow_over_budget=False), show time until reset
                    const timeUntilReset = decision.time_until_reset;
                    if (timeUntilReset && String(timeUntilReset).trim() !== '' && timeUntilReset !== 'null' && timeUntilReset !== null) {
                        tooltipText = `Budget resets in ${timeUntilReset}`;
                    } else {
                        tooltipText = 'Budget resets monthly';
                    }
                } else {
                    // When allow_over_budget=True, budget does not reset
                    tooltipText = 'Budget does not reset in this mode';
                }
                
                // Set tooltip using Bootstrap tooltip API
                // Destroy existing tooltip instance if any
                const existingTooltip = bootstrap.Tooltip.getInstance(remainingBudgetElem);
                if (existingTooltip) {
                    existingTooltip.dispose();
                }
                
                // Update title attribute
                remainingBudgetElem.setAttribute('data-bs-original-title', tooltipText);
                remainingBudgetElem.setAttribute('title', tooltipText);
                
                // Initialize new Bootstrap tooltip
                new bootstrap.Tooltip(remainingBudgetElem, {
                    placement: 'top',
                    trigger: 'hover'
                });
                
                // Debug: log tooltip setting
                console.log('Budget tooltip set:', {
                    budget_resets: decision.budget_resets,
                    time_until_reset: decision.time_until_reset,
                    tooltip: tooltipText,
                    element_title: remainingBudgetElem.getAttribute('title')
                });
            } else {
                remainingBudgetElem.textContent = '--';
                const tooltipText = 'Budget information unavailable';
                
                // Update Bootstrap tooltip
                const existingTooltip = bootstrap.Tooltip.getInstance(remainingBudgetElem);
                if (existingTooltip) {
                    existingTooltip.dispose();
                }
                remainingBudgetElem.setAttribute('data-bs-original-title', tooltipText);
                remainingBudgetElem.setAttribute('title', tooltipText);
                new bootstrap.Tooltip(remainingBudgetElem, {
                    placement: 'top',
                    trigger: 'hover'
                });
            }
                // Update Test Strategy Button State
                const btn = document.getElementById('executeSimulatedBtn');
                const warningBox = document.getElementById('metricsWarning');

                if (decision.reason.includes("Metrics unavailable") || decision.reason.includes("stale")) {
                    warningBox.classList.remove('d-none');
                    btn.disabled = true;
                    btn.textContent = 'Metrics Error';
                } else {
                    warningBox.classList.add('d-none');
                    if (decision.can_execute) {
                        btn.disabled = false;
                        btn.textContent = `Test Strategy ($${decision.suggested_amount_usd.toFixed(2)})`;
                    } else {
                        btn.disabled = true;
                        btn.textContent = 'Conditions Not Met';
                    }
                }
        }

        async function loadPreview() {
            try {
                // 1. Strategy
                const cachedStrat = loadFromCache('strategy_config');
                if (cachedStrat) updateStrategyUI(cachedStrat);
                
                const stratResponse = await fetch('/api/strategy');
                const strategy = await stratResponse.json();
                saveToCache('strategy_config', strategy);
                updateStrategyUI(strategy);

                // 2. Preview
                const cachedPreview = loadFromCache('dca_preview');
                if (cachedPreview) updatePreviewUI(cachedPreview);

                const response = await fetch('/api/dca/preview');
                const decision = await response.json();
                saveToCache('dca_preview', decision);
                updatePreviewUI(decision);
                
            } catch (error) {
                console.error('Error loading preview:', error);
                const reasonElem = document.getElementById('previewReason');
                if (reasonElem) reasonElem.textContent = 'Error loading data';
                notyf.error('Failed to load metrics');
            }
        }
        
        // Helper to update global refresh timestamp
        function updateGlobalRefreshTime(timestamp) {
            const elem = document.getElementById('globalRefreshTime');
            if (elem && timestamp) {
                elem.textContent = formatGlobalRefreshTime(timestamp);
            }
        }

        // Global refresh button handler
        document.addEventListener('DOMContentLoaded', function() {
            const globalBtn = document.getElementById('globalRefreshBtn');
            if (globalBtn) {
                globalBtn.addEventListener('click', async () => {
                    globalBtn.disabled = true;
                    globalBtn.textContent = 'üîÑ Syncing Trades...';
                    
                    try {
                        // 1. Trigger Sync
                        const syncResponse = await fetch('/api/transactions/sync', { method: 'POST' });
                        const syncResult = await syncResponse.json();
                        
                        if (syncResult.success && syncResult.new_trades_count > 0) {
                            notyf.success(`Synced ${syncResult.new_trades_count} new trades`);
                        }
                        
                        // 2. Refresh Dashboard Data
                        globalBtn.textContent = 'üîÑ Loading Data...';
                        await Promise.all([
                            loadTransactions(), // Reload list from DB (fast)
                            loadPreview(),
                            loadWalletSummary()
                        ]);
                        notyf.success('Dashboard refreshed');
                    } catch (error) {
                        console.error('Refresh failed:', error);
                        notyf.error('Failed to refresh dashboard');
                    } finally {
                        globalBtn.disabled = false;
                        globalBtn.textContent = 'üîÑ Refresh Dashboard';
                    }
                });
            }
        });

        document.getElementById('executeSimulatedBtn').addEventListener('click', async () => {
            const btn = document.getElementById('executeSimulatedBtn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Executing...';

            try {
                const response = await fetch('/api/dca/execute-simulated', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.transaction) {
                    notyf.success(`Simulated buy executed: ${result.message}`);
                    // Auto-refresh after successful execution (Phase 6)
                    loadTransactions(); // Refresh history
                    loadPreview();      // Refresh preview (budget might have changed)
                } else {
                    notyf.open({ type: 'warning', message: `Skipped: ${result.message}` });
                    // Don't refresh transactions if skipped, but refresh preview to show updated status
                    loadPreview();
                }
            } catch (error) {
                console.error('Error executing simulated DCA:', error);
                notyf.error('Execution failed');
                btn.disabled = false;
                btn.textContent = originalText;
            }
        });

        // Holdings function still needed by dashboard
        function updateWalletUI(data, strategy) {
            // Always show content (cold wallet always available)
            document.getElementById('walletContent').classList.remove('d-none');
            
            // Total BTC (main display)
            document.getElementById('totalBtc').textContent = data.total_btc.toFixed(8) + ' BTC';
            
            // Breakdown - Hot and Cold
            const hotText = data.hot_wallet_balance.toFixed(8);
            const coldText = data.cold_wallet_balance.toFixed(8);
            document.getElementById('hotBalance').textContent = `Hot: ${hotText}`;
            document.getElementById('coldBalance').textContent = `Cold: ${coldText}`;
            
            // Pre-fill modal with current cold wallet balance
            document.getElementById('coldWalletInput').value = data.cold_wallet_balance;
            
            // Show warning if no Binance credentials (hot wallet will be 0)
            const errorBox = document.getElementById('walletError');
            if (data.hot_wallet_balance === 0 && data.hot_wallet_avg_price === 0) {
                errorBox.classList.remove('d-none');
            } else {
                errorBox.classList.add('d-none');
            }
            
            // Update Progress Bar
            if (strategy) {
                const target = strategy.target_btc_amount || 1.0;
                const progress = Math.min((data.total_btc / target) * 100, 100).toFixed(4);
                document.getElementById('progressPercent').textContent = progress + '%';
                document.getElementById('targetAmount').textContent = `Target: ${target} BTC`;
                document.getElementById('progressBar').style.width = progress + '%';
            }
        }

        async function loadWalletSummary() {
            try {
                // 1. Load all cached data FIRST for instant display
                const cachedWallet = loadFromCache('wallet_summary');
                const cachedStrategy = loadFromCache('strategy_config');
                const cachedBinance = loadFromCache('binance_holdings');
                
                if (cachedWallet) updateWalletUI(cachedWallet, cachedStrategy);
                
                // Show cached USDC immediately
                if (cachedBinance && cachedBinance.quote_balance !== null && cachedBinance.quote_balance !== undefined) {
                    document.getElementById('quoteBalance').textContent = '$' + cachedBinance.quote_balance.toFixed(2);
                }
                
                // 2. Fetch fresh wallet data
                const response = await fetch('/api/wallet/summary');
                const data = await response.json();
                saveToCache('wallet_summary', data);
                
                // 3. Fetch strategy (for progress bar)
                const stratResponse = await fetch('/api/strategy');
                const strategy = await stratResponse.json();
                
                updateWalletUI(data, strategy);
                
                // 4. Fetch fresh Binance holdings
                try {
                    const binanceResponse = await fetch('/api/binance/holdings');
                    const binanceData = await binanceResponse.json();
                    saveToCache('binance_holdings', binanceData);
                    
                    if (binanceData.connected && binanceData.quote_balance !== null) {
                        document.getElementById('quoteBalance').textContent = '$' + binanceData.quote_balance.toFixed(2);
                    }
                } catch (err) {
                    console.log('Could not fetch quote balance:', err);
                }
                
            } catch (error) {
                console.error('Error loading wallet summary:', error);
                notyf.error('Failed to load wallet data');
            }
        }

        // Set Cold Wallet Balance Form
        document.getElementById('setColdWalletForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const balance = parseFloat(document.getElementById('coldWalletInput').value);
            
            try {
                const response = await fetch('/api/wallet/cold-balance', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ balance: balance })
                });
                
                if (response.ok) {
                    notyf.success('Cold wallet balance updated!');
                    const modal = bootstrap.Modal.getInstance(document.getElementById('setColdWalletModal'));
                    modal.hide();
                    loadWalletSummary();  // Refresh the wallet display
                } else {
                    const err = await response.json();
                    notyf.error('Error: ' + (err.detail || 'Failed to update balance'));
                }
            } catch (error) {
                notyf.error('Network error');
                console.error(error);
            }
        });

        // Execution Mode Management (Phase 9)
        let currentExecutionMode = 'DRY_RUN';  // Global variable to track mode
        let clearConfirmationActive = false;
        let clearConfirmationTimeout = null;

        async function loadExecutionMode() {
            try {
                const response = await fetch('/api/strategy');
                const strategy = await response.json();
                if (strategy) {
                    currentExecutionMode = strategy.execution_mode || 'DRY_RUN';
                    updateModeIndicator(currentExecutionMode);
                    updateClearButtonVisibility(currentExecutionMode);
                }
            } catch (error) {
                console.error('Error loading execution mode:', error);
                // Default to DRY_RUN on error
                currentExecutionMode = 'DRY_RUN';
                updateModeIndicator('DRY_RUN');
            }
        }

        function updateModeIndicator(mode) {
            const badge = document.getElementById('execModeBadge');
            if (!badge) return;
            
            if (mode === 'LIVE') {
                badge.className = 'badge bg-danger me-2';
                badge.textContent = 'Mode: LIVE';
            } else {
                badge.className = 'badge bg-secondary me-2';
                badge.textContent = 'Mode: Dry Run';
            }
        }

        function updateClearButtonVisibility(mode) {
            const clearBtn = document.getElementById('clearSimulatedBtn');
            if (!clearBtn) return;
            
            // Always show the button now
            clearBtn.style.display = 'inline-block';
        }

        // Clear Simulated Transactions with Two-Click Confirmation
        document.addEventListener('DOMContentLoaded', function() {
            const clearBtn = document.getElementById('clearSimulatedBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', async () => {
                    // Available in all modes now

                    
                    if (!clearConfirmationActive) {
                        // First click: activate confirmation
                        clearConfirmationActive = true;
                        clearBtn.textContent = 'Click again to confirm';
                        clearBtn.classList.remove('btn-outline-danger');
                        clearBtn.classList.add('btn-danger');
                        
                        // Reset after 3 seconds
                        clearConfirmationTimeout = setTimeout(() => {
                            resetClearButton();
                        }, 3000);
                    } else {
                        // Second click: execute clear
                        clearTimeout(clearConfirmationTimeout);
                        clearBtn.disabled = true;
                        clearBtn.textContent = 'Clearing...';
                        
                        try {
                            const response = await fetch('/api/transactions/clear-simulated', {
                                method: 'POST'
                            });
                            
                            const result = await response.json();
                            
                            if (response.ok && result.success) {
                                notyf.success(result.message || 'Simulated transactions cleared');
                                loadTransactions();  // Refresh the transaction list
                                loadPreview();  // Refresh the preview (budget might have changed)
                            } else {
                                notyf.error(result.detail || result.message || 'Failed to clear transactions');
                            }
                        } catch (error) {
                            console.error('Error clearing simulated transactions:', error);
                            notyf.error('Network error or backend unreachable');
                        } finally {
                            resetClearButton();
                        }
                    }
                });
            }
        });

        function resetClearButton() {
            const clearBtn = document.getElementById('clearSimulatedBtn');
            if (clearBtn) {
                clearConfirmationActive = false;
                clearBtn.disabled = false;
                clearBtn.textContent = 'Reset & Sync History';
                clearBtn.classList.remove('btn-danger');
                clearBtn.classList.add('btn-outline-danger');
            }
        }

        
        // Server-Sent Events for real-time updates
        let eventSource = null;
        
        function connectSSE() {
            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }
            
            // Connect to SSE endpoint
            eventSource = new EventSource('/api/events');
            
            eventSource.addEventListener('transaction_created', (event) => {
                console.log('New transaction event received:', event.data);
                notyf.success('New DCA transaction executed!');
                
                // Refresh all data immediately
                loadTransactions();
                loadPreview();
                loadWalletSummary();
            });
            
            eventSource.addEventListener('ping', () => {
                // Keepalive ping, do nothing
            });
            
            eventSource.onerror = (error) => {
                console.error('SSE connection error:', error);
                eventSource.close();
                
                // Reconnect after 5 seconds
                setTimeout(connectSSE, 5000);
            };
            
            console.log('‚úì Connected to real-time updates');
        }
        
        // Load on start
        loadExecutionMode();
        loadTransactions();
        loadPreview();
        loadWalletSummary();
        connectSSE();  // Connect to server-sent events for real-time updates
    </script>
</body>
</html>
